/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// main.ts
__export(exports, {
  default: () => FlatTagPlugin
});
var import_obsidian2 = __toModule(require("obsidian"));

// flatTagView.ts
var import_obsidian = __toModule(require("obsidian"));

// constants.ts
var VIEW_TYPE = "flat-tag-view";

// flatTagView.ts
var FlatTagView = class extends import_obsidian.ItemView {
  constructor(leaf) {
    super(leaf);
    this.selectedTags = new Set();
    this.excludedTags = new Set();
    this.allTags = new Map();
    this.currentSort = "az";
    this.tagsByFile = new Map();
    this.hideSingleUseTags = false;
    this.showAlphabetLetters = false;
    this.tagSearchText = "";
    this.containerEl.addClass("flat-tag-view");
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Flat Tags";
  }
  getIcon() {
    return "tag";
  }
  async onOpen() {
    this.container = this.contentEl.createDiv({ cls: "flat-tag-container" });
    this.sortContainer = this.container.createDiv({ cls: "flat-tag-sort-container" });
    const buttonSection = this.sortContainer.createDiv({ cls: "flat-tag-buttons-section" });
    const sortByAZ = buttonSection.createDiv({ cls: "flat-tag-sort-button", title: "Sort A-Z" });
    (0, import_obsidian.setIcon)(sortByAZ, "lucide-sort-asc");
    sortByAZ.addEventListener("click", () => {
      this.currentSort = "az";
      this.renderTags();
    });
    const sortByCount = buttonSection.createDiv({ cls: "flat-tag-sort-button", title: "Sort by usage" });
    (0, import_obsidian.setIcon)(sortByCount, "lucide-bar-chart-2");
    sortByCount.addEventListener("click", () => {
      this.currentSort = "count";
      this.renderTags();
    });
    const clearButton = buttonSection.createDiv({ cls: "flat-tag-clear-button" });
    (0, import_obsidian.setIcon)(clearButton, "x");
    clearButton.addEventListener("click", () => {
      this.clearTagSelections();
    });
    const toggleSingleUseButton = buttonSection.createDiv({
      cls: "flat-tag-sort-button",
      title: "Toggle single-use tags"
    });
    (0, import_obsidian.setIcon)(toggleSingleUseButton, "eye-off");
    toggleSingleUseButton.addEventListener("click", () => {
      this.toggleSingleUseTags();
      (0, import_obsidian.setIcon)(toggleSingleUseButton, this.hideSingleUseTags ? "eye" : "eye-off");
    });
    const toggleAlphabetButton = buttonSection.createDiv({
      cls: "flat-tag-sort-button",
      title: "Toggle alphabet letters"
    });
    (0, import_obsidian.setIcon)(toggleAlphabetButton, "lucide-brick-wall");
    toggleAlphabetButton.addEventListener("click", () => {
      this.toggleAlphabetLetters();
      (0, import_obsidian.setIcon)(toggleAlphabetButton, this.showAlphabetLetters ? "cuboid" : "lucide-brick-wall");
    });
    const searchSection = this.sortContainer.createDiv({ cls: "flat-tag-search-section" });
    const searchBox = searchSection.createEl("input", {
      cls: "flat-tag-search-input",
      attr: {
        type: "text",
        placeholder: "Search tags..."
      }
    });
    const clearSearchButton = searchSection.createDiv({
      cls: "flat-tag-search-clear-button",
      title: "Clear search"
    });
    (0, import_obsidian.setIcon)(clearSearchButton, "square-x");
    clearSearchButton.addEventListener("click", () => {
      this.clearSearchBox();
    });
    searchBox.addEventListener("input", (e) => {
      const target = e.target;
      this.tagSearchText = target.value;
      this.renderTags();
    });
    this.tagContainer = this.container.createDiv({ cls: "flat-tag-list" });
    await this.loadTags();
    this.registerEvent(this.app.metadataCache.on("resolved", () => {
      this.loadTags();
    }));
  }
  async loadTags() {
    this.allTags.clear();
    this.tagsByFile.clear();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const fileTags = this.getFileTags(file);
      this.tagsByFile.set(file.path, new Set(fileTags));
      fileTags.forEach((tag) => {
        this.allTags.set(tag, (this.allTags.get(tag) || 0) + 1);
      });
    }
    this.renderTags();
  }
  renderTags() {
    this.tagContainer.empty();
    const filteredTags = this.getFilteredTags();
    let sortedTags;
    if (this.currentSort === "az") {
      sortedTags = Array.from(filteredTags.entries()).sort((a, b) => a[0].localeCompare(b[0], "pl"));
    } else {
      sortedTags = Array.from(filteredTags.entries()).sort((a, b) => b[1] - a[1]);
    }
    if (this.showAlphabetLetters && this.currentSort === "az") {
      const tagsByLetter = new Map();
      tagsByLetter.set("other", []);
      for (let charCode = 65; charCode <= 90; charCode++) {
        const letter = String.fromCharCode(charCode);
        tagsByLetter.set(letter, []);
      }
      const polishDiacritics = ["\u0104", "\u0106", "\u0118", "\u0141", "\u0143", "\xD3", "\u015A", "\u0179", "\u017B"];
      polishDiacritics.forEach((letter) => tagsByLetter.set(letter, []));
      sortedTags.forEach((tagItem) => {
        const [tag, count] = tagItem;
        const firstChar = tag.charAt(0).toUpperCase();
        if (firstChar.match(/[A-Z]/)) {
          const letterTags = tagsByLetter.get(firstChar) || [];
          letterTags.push(tagItem);
          tagsByLetter.set(firstChar, letterTags);
        } else if (polishDiacritics.includes(firstChar)) {
          const letterTags = tagsByLetter.get(firstChar) || [];
          letterTags.push(tagItem);
          tagsByLetter.set(firstChar, letterTags);
        } else {
          const otherTags = tagsByLetter.get("other") || [];
          otherTags.push(tagItem);
          tagsByLetter.set("other", otherTags);
        }
      });
      tagsByLetter.forEach((letterTags, letter) => {
        if (letterTags.length > 0) {
          if (letter !== "other") {
            const letterEl = this.tagContainer.createSpan({ cls: "flat-tag-letter" });
            letterEl.setText(letter);
          }
          letterTags.forEach(([tag, count]) => {
            this.createTagElement(tag, count);
          });
        }
      });
    } else {
      sortedTags.forEach(([tag, count]) => {
        this.createTagElement(tag, count);
      });
    }
  }
  createTagElement(tag, count) {
    const tagEl = this.tagContainer.createSpan({ cls: "flat-tag" });
    if (this.selectedTags.has(tag)) {
      tagEl.addClass("flat-tag-selected");
    } else if (this.excludedTags.has(tag)) {
      tagEl.addClass("flat-tag-excluded");
    }
    tagEl.setText(`#${tag} (${count})`);
    tagEl.addEventListener("click", (e) => {
      const isMultiSelect = e.ctrlKey || e.metaKey;
      const isExclude = e.shiftKey && isMultiSelect;
      if (isExclude) {
        if (this.excludedTags.has(tag)) {
          this.excludedTags.delete(tag);
        } else {
          this.excludedTags.add(tag);
          this.selectedTags.delete(tag);
        }
      } else if (isMultiSelect) {
        if (this.selectedTags.has(tag)) {
          this.selectedTags.delete(tag);
        } else {
          this.selectedTags.add(tag);
          this.excludedTags.delete(tag);
        }
      } else {
        if (this.selectedTags.size === 1 && this.selectedTags.has(tag)) {
          this.selectedTags.clear();
        } else {
          this.selectedTags.clear();
          this.excludedTags.clear();
          this.selectedTags.add(tag);
        }
      }
      this.renderTags();
      this.updateSearch();
    });
  }
  getFilteredTags() {
    let filteredTags = new Map();
    if (this.selectedTags.size === 0) {
      filteredTags = new Map(this.allTags);
    } else {
      const selectedTagsArray = Array.from(this.selectedTags);
      const matchingFiles = [];
      this.tagsByFile.forEach((tags, filePath) => {
        if (selectedTagsArray.every((tag) => tags.has(tag))) {
          matchingFiles.push(filePath);
        }
      });
      matchingFiles.forEach((filePath) => {
        const fileTags = this.tagsByFile.get(filePath);
        if (fileTags) {
          fileTags.forEach((tag) => {
            filteredTags.set(tag, (filteredTags.get(tag) || 0) + 1);
          });
        }
      });
      selectedTagsArray.forEach((tag) => {
        if (!filteredTags.has(tag)) {
          filteredTags.set(tag, this.allTags.get(tag) || 0);
        }
      });
    }
    if (this.hideSingleUseTags) {
      const result = new Map();
      filteredTags.forEach((count, tag) => {
        if (count > 1 || this.selectedTags.has(tag)) {
          result.set(tag, count);
        }
      });
      filteredTags = result;
    }
    if (this.tagSearchText) {
      const searchText = this.tagSearchText.toLowerCase();
      const result = new Map();
      filteredTags.forEach((count, tag) => {
        if (tag.toLowerCase().includes(searchText) || this.selectedTags.has(tag) || this.excludedTags.has(tag)) {
          result.set(tag, count);
        }
      });
      return result;
    }
    return filteredTags;
  }
  updateSearch() {
    if (this.selectedTags.size === 0 && this.excludedTags.size === 0) {
      this.app.workspace.getLeavesOfType("search").forEach((leaf) => {
        const searchView = leaf.view;
        if (searchView && typeof searchView.clearSearch === "function") {
          searchView.clearSearch();
        }
      });
      return;
    }
    const tagQuery = [
      ...Array.from(this.selectedTags).map((tag) => `tag:#${tag}`),
      ...Array.from(this.excludedTags).map((tag) => `-tag:#${tag}`)
    ].join(" ");
    let searchLeaf = this.app.workspace.getLeavesOfType("search")[0];
    if (!searchLeaf) {
      const rightLeaf = this.app.workspace.getRightLeaf(false);
      if (rightLeaf) {
        searchLeaf = rightLeaf;
        searchLeaf.setViewState({ type: "search" });
      }
    }
    if (searchLeaf) {
      const searchView = searchLeaf.view;
      if (searchView && typeof searchView.setQuery === "function") {
        searchView.setQuery(tagQuery);
        searchView.search();
      }
      this.app.workspace.revealLeaf(searchLeaf);
    }
  }
  getFileTags(file) {
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache)
      return [];
    const tags = new Set();
    if (cache.tags) {
      cache.tags.forEach((tagObj) => {
        const tag = tagObj.tag.replace(/^#/, "");
        tags.add(tag);
      });
    }
    if (cache.frontmatter && cache.frontmatter.tags) {
      const fmTags = cache.frontmatter.tags;
      if (typeof fmTags === "string") {
        fmTags.split(/[,\s]+/).filter(Boolean).forEach((tag) => {
          tags.add(tag);
        });
      } else if (Array.isArray(fmTags)) {
        fmTags.forEach((tag) => {
          if (tag)
            tags.add(String(tag));
        });
      }
    }
    return Array.from(tags);
  }
  toggleSort() {
    this.currentSort = this.currentSort === "az" ? "count" : "az";
    this.renderTags();
  }
  clearTagSelections() {
    this.selectedTags.clear();
    this.excludedTags.clear();
    this.renderTags();
    this.updateSearch();
  }
  toggleSingleUseTags() {
    this.hideSingleUseTags = !this.hideSingleUseTags;
    this.renderTags();
  }
  toggleAlphabetLetters() {
    this.showAlphabetLetters = !this.showAlphabetLetters;
    this.renderTags();
  }
  clearSearchBox() {
    const searchBox = this.contentEl.querySelector(".flat-tag-search-input");
    if (searchBox) {
      searchBox.value = "";
      this.tagSearchText = "";
      this.renderTags();
    }
  }
};

// styles.ts
var getStyles = () => {
  return `
    .workspace-split.mod-root .view-content.flat-tag-view {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: stretch;
      height: 100%;
      padding: 0;
      margin: 0;
    }

    .flat-tag-container {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      padding: 0;
      margin: 0;
    }

    .flat-tag-sort-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
      padding: 8px;
      background-color: var(--background-primary);
      border-bottom: 1px solid var(--background-modifier-border);
      width: 100%;
    }
    
    .flat-tag-buttons-section {
      display: flex;
      gap: 8px;
    }
    
    .flat-tag-search-section {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-left: auto;
      background-color: var(--background-secondary);
      border-radius: 4px;
      padding: 2px 8px;
    }
    
    .flat-tag-search-input {
      background: transparent;
      border: none;
      color: var(--text-normal);
      width: 150px;
      height: 24px;
      font-size: 0.9em;
    }
    
    .flat-tag-search-input:focus {
      outline: none;
      box-shadow: none;
    }
    
    .flat-tag-search-icon {
      color: var(--text-muted);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .flat-tag-search-clear-button {
      cursor: pointer;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8em;
    }

    .flat-tag-search-clear-button:hover {
      color: var(--text-normal);
    }

    .flat-tag-sort-button, .flat-tag-clear-button {
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
    }

    .flat-tag-sort-button:hover, .flat-tag-clear-button:hover {
      background-color: var(--interactive-hover);
    }

    .flat-tag-list {
      display: flex;
      flex-wrap: wrap;
      align-content: flex-start;
      overflow-y: auto;
      flex: 1;
      line-height: 1.5em;
      padding: 8px;
      width: 100%;
    }

    .flat-tag {
      display: inline-block;
      padding: 2px 6px;
      margin: 2px;
      border-radius: 4px;
      cursor: pointer;
      background-color: var(--tag-background);
      color: var(--tag-color);
    }

    .flat-tag:hover {
      background-color: var(--tag-background-hover);
    }

    .flat-tag-selected {
      font-weight: bold;
      background-color: var(--interactive-accent);
      color: var(--text-on-accent);
    }

    .flat-tag-excluded {
      font-weight: bold;
      background-color: var(--color-red);
      color: var(--text-on-accent);
    }
    
    .flat-tag-letter {
      display: inline-block;
      font-weight: bold;
      font-size: 1.2em;
      margin: 2px;
      padding: 2px 6px;
      border-radius: 4px;
      background-color: var(--background-secondary);
      color: var(--text-normal);
      vertical-align: middle;
    }
  `;
};

// main.ts
var FlatTagPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    this.registerView(VIEW_TYPE, (leaf) => new FlatTagView(leaf));
    this.addRibbonIcon("tag", "Open Flat Tags", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-flat-tags",
      name: "Open Flat Tags",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "toggle-flat-tag-sort",
      name: "Toggle Flat Tag Sort (A-Z/Usage)",
      callback: () => {
        var _a;
        const view = (_a = this.app.workspace.getLeavesOfType(VIEW_TYPE)[0]) == null ? void 0 : _a.view;
        if (view)
          view.toggleSort();
      }
    });
    this.addCommand({
      id: "clear-flat-tag-selections",
      name: "Clear Flat Tag Selections",
      callback: () => {
        var _a;
        const view = (_a = this.app.workspace.getLeavesOfType(VIEW_TYPE)[0]) == null ? void 0 : _a.view;
        if (view)
          view.clearTagSelections();
      }
    });
    this.addCommand({
      id: "toggle-flat-tag-single-use",
      name: "Toggle Flat Tag Single Use",
      callback: () => {
        var _a;
        const view = (_a = this.app.workspace.getLeavesOfType(VIEW_TYPE)[0]) == null ? void 0 : _a.view;
        if (view)
          view.toggleSingleUseTags();
      }
    });
    this.addCommand({
      id: "toggle-flat-tag-alphabet",
      name: "Toggle Flat Tag Alphabet Letters",
      callback: () => {
        var _a;
        const view = (_a = this.app.workspace.getLeavesOfType(VIEW_TYPE)[0]) == null ? void 0 : _a.view;
        if (view)
          view.toggleAlphabetLetters();
      }
    });
    this.addCommand({
      id: "clear-flat-tag-search",
      name: "Clear Flat Tag Search Box",
      callback: () => {
        var _a;
        const view = (_a = this.app.workspace.getLeavesOfType(VIEW_TYPE)[0]) == null ? void 0 : _a.view;
        if (view)
          view.clearSearchBox();
      }
    });
    this.addStyle();
  }
  async onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({ type: VIEW_TYPE });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  addStyle() {
    const styleEl = document.createElement("style");
    styleEl.innerHTML = getStyles();
    document.head.appendChild(styleEl);
  }
};
