/* 
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD 
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FlatTagPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// constants.ts
var VIEW_TYPE = "flat-tag-view";

// flatTagView.ts
var import_obsidian = require("obsidian");
var GlobalMuteConfirmModal = class extends import_obsidian.Modal {
  constructor(app, tagToMute, onConfirm) {
    super(app);
    this.tagToMute = tagToMute;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Global Mute Tag" });
    const isCurrentlyMuted = this.tagToMute.startsWith("%");
    const targetState = isCurrentlyMuted ? "UN-MUTE" : "MUTE";
    const resultingTag = isCurrentlyMuted ? `#${this.tagToMute.slice(1)}` : `#%${this.tagToMute}`;
    contentEl.createEl("p", {
      text: `Are you sure you want to globally ${targetState} the tag #${this.tagToMute}?`
    });
    contentEl.createEl("p", {
      text: `This will search your entire vault and change every instance to ${resultingTag}. This action modifies your files and cannot be easily undone.`
    });
    new import_obsidian.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => this.close())
    ).addButton(
      (btn) => btn.setButtonText(`Yes, ${targetState} Globally`).setCta().onClick(() => {
        this.onConfirm();
        this.close();
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var FlatTagView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.selectedTags = /* @__PURE__ */ new Set();
    this.excludedTags = /* @__PURE__ */ new Set();
    this.allTags = /* @__PURE__ */ new Map();
    this.tagsByFile = /* @__PURE__ */ new Map();
    this.currentSort = "az";
    this.searchMode = "note";
    this.tagSearchText = "";
    this.touchTimer = null;
    this.lastInteractionWasTouch = false;
    this.plugin = plugin;
    this.containerEl.addClass("flat-tag-view");
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Flat Tags";
  }
  getIcon() {
    return "tag";
  }
  async onOpen() {
    this.container = this.contentEl.createDiv({ cls: "flat-tag-container" });
    this.containerEl.addEventListener("touchstart", () => {
      this.lastInteractionWasTouch = true;
    }, { passive: true });
    this.containerEl.addEventListener("pointerdown", (e) => {
      if (e.pointerType && e.pointerType !== "touch")
        this.lastInteractionWasTouch = false;
    }, { passive: true });
    this.sortContainer = this.container.createDiv({ cls: "flat-tag-sort-container" });
    const buttonSection = this.sortContainer.createDiv({ cls: "flat-tag-buttons-section" });
    this.sortAzBtn = buttonSection.createDiv({ cls: "flat-tag-sort-button", title: "Sort A-Z" });
    (0, import_obsidian.setIcon)(this.sortAzBtn, "lucide-sort-asc");
    this.sortCountBtn = buttonSection.createDiv({ cls: "flat-tag-sort-button", title: "Sort by usage" });
    (0, import_obsidian.setIcon)(this.sortCountBtn, "lucide-bar-chart-2");
    const clearButton = buttonSection.createDiv({ cls: "flat-tag-clear-button", title: "Clear tag selections" });
    (0, import_obsidian.setIcon)(clearButton, "x");
    clearButton.addEventListener("click", () => this.clearTagSelections());
    this.scopeBtn = buttonSection.createDiv({
      cls: "flat-tag-mode-button",
      text: "NOTE",
      title: "Click to cycle: Note -> Line"
    });
    this.taskBtn = buttonSection.createDiv({
      cls: "flat-tag-mode-button",
      text: "TASK-ALL",
      title: "Click to cycle: All -> Todo -> Done"
    });
    const cutoffSpacer = buttonSection.createDiv({ cls: "flat-tag-cutoff-spacer" });
    cutoffSpacer.ariaHidden = "true";
    const cutoffSection = buttonSection.createDiv({ cls: "flat-tag-cutoff-section" });
    this.cutoffToggleBtn = cutoffSection.createDiv({ cls: "flat-tag-cutoff-toggle", title: "Toggle frequency cutoff" });
    this.cutoffInput = cutoffSection.createEl("input", {
      cls: "flat-tag-cutoff-input",
      attr: { type: "number", min: "0", step: "1", inputmode: "numeric", placeholder: "0" }
    });
    this.cutoffToggleBtn.addEventListener("click", async () => {
      this.plugin.settings.frequencyCutoffEnabled = !this.plugin.settings.frequencyCutoffEnabled;
      await this.plugin.saveSettings();
      this.syncCutoffControlsFromSettings();
      this.renderTags();
    });
    this.cutoffInput.addEventListener("input", async () => {
      const parsed = parseInt(this.cutoffInput.value, 10);
      if (!isNaN(parsed) && parsed >= 0) {
        this.plugin.settings.frequencyCutoff = parsed;
        await this.plugin.saveSettings();
        this.renderTags();
      }
    });
    this.sortAzBtn.addEventListener("click", () => {
      if (this.currentSort === "az") {
        const vaultName = this.app.vault.getName();
        const count = Object.keys(this.app.metadataCache.getTags()).length;
        new import_obsidian.Notice(`'${vaultName}': ${count} unique tags`);
      } else {
        this.currentSort = "az";
        this.updateModeUI(true);
      }
    });
    this.sortCountBtn.addEventListener("click", () => {
      if (this.currentSort === "count") {
        const vaultName = this.app.vault.getName();
        const count = Object.keys(this.app.metadataCache.getTags()).length;
        new import_obsidian.Notice(`'${vaultName}': ${count} unique tags`);
      } else {
        this.currentSort = "count";
        this.updateModeUI(true);
      }
    });
    this.scopeBtn.addEventListener("click", () => this.toggleScopeMode());
    this.taskBtn.addEventListener("click", () => this.toggleTaskMode());
    const searchSection = this.sortContainer.createDiv({ cls: "flat-tag-search-section" });
    const searchBox = searchSection.createEl("input", {
      cls: "flat-tag-search-input",
      attr: { type: "text", placeholder: "Search tags..." }
    });
    const clearSearchButton = searchSection.createDiv({ cls: "flat-tag-search-clear-button", title: "Clear search" });
    (0, import_obsidian.setIcon)(clearSearchButton, "square-x");
    clearSearchButton.addEventListener("click", () => this.clearSearchBox());
    searchBox.addEventListener("input", (e) => {
      var _a;
      const target = e.target;
      this.tagSearchText = (_a = target.value) != null ? _a : "";
      this.renderTags();
    });
    this.tagContainer = this.container.createDiv({ cls: "flat-tag-list" });
    this.syncCutoffControlsFromSettings();
    this.updateModeUI(true);
    await this.loadTags();
    this.registerEvent(this.app.metadataCache.on("changed", (file) => {
      this.updateFileTags(file);
    }));
    this.registerEvent(this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        this.removeFileTags(file.path);
        this.renderTags();
      }
    }));
    this.registerEvent(this.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        const tags = this.tagsByFile.get(oldPath);
        if (tags) {
          this.tagsByFile.set(file.path, tags);
          this.tagsByFile.delete(oldPath);
        }
      }
    }));
    this.registerEvent(this.app.workspace.on("flat-tag-view:settings-updated", () => {
      this.syncCutoffControlsFromSettings();
      this.renderTags();
    }));
  }
  async onClose() {
    this.contentEl.empty();
  }
  async loadTags() {
    this.allTags.clear();
    this.tagsByFile.clear();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const fileTags = this.getFileTags(file);
      this.tagsByFile.set(file.path, fileTags);
      fileTags.forEach((tag) => this.allTags.set(tag, (this.allTags.get(tag) || 0) + 1));
    }
    this.renderTags();
  }
  updateFileTags(file) {
    const oldTagsArr = this.tagsByFile.get(file.path) || [];
    const newTagsArr = this.getFileTags(file);
    const oldSorted = [...oldTagsArr].sort().join(",");
    const newSorted = [...newTagsArr].sort().join(",");
    if (oldSorted === newSorted)
      return;
    oldTagsArr.forEach((tag) => {
      const count = (this.allTags.get(tag) || 0) - 1;
      if (count <= 0)
        this.allTags.delete(tag);
      else
        this.allTags.set(tag, count);
    });
    newTagsArr.forEach((tag) => this.allTags.set(tag, (this.allTags.get(tag) || 0) + 1));
    this.tagsByFile.set(file.path, newTagsArr);
    this.renderTags();
  }
  removeFileTags(filePath) {
    const oldTags = this.tagsByFile.get(filePath);
    if (!oldTags)
      return;
    oldTags.forEach((tag) => {
      const count = (this.allTags.get(tag) || 0) - 1;
      if (count <= 0)
        this.allTags.delete(tag);
      else
        this.allTags.set(tag, count);
    });
    this.tagsByFile.delete(filePath);
  }
  async renderTags() {
    var _a;
    this.tagContainer.empty();
    this.sortAzBtn.toggleClass("is-active", this.currentSort === "az");
    this.sortCountBtn.toggleClass("is-active", this.currentSort === "count");
    const filteredTags = await this.getFilteredTagsAsync();
    const pinned = /* @__PURE__ */ new Map();
    const normal = /* @__PURE__ */ new Map();
    const pinnedSet = new Set((_a = this.plugin.settings.pinnedTags) != null ? _a : []);
    filteredTags.forEach((count, tag) => {
      if (pinnedSet.has(tag))
        pinned.set(tag, count);
      else
        normal.set(tag, count);
    });
    if (pinned.size > 0) {
      const pinContainer = this.tagContainer.createDiv({ cls: "flat-tag-pinned-section" });
      const pinnedIcon = pinContainer.createSpan({ cls: "flat-tag-letter" });
      (0, import_obsidian.setIcon)(pinnedIcon, "pin");
      Array.from(pinned.entries()).sort((a, b) => a[0].localeCompare(b[0], "pl")).forEach(([tag, count]) => this.createTagElement(tag, count, pinContainer));
      this.tagContainer.createDiv({ cls: "flat-tag-separator" });
    }
    let sortedTags = Array.from(normal.entries());
    if (this.currentSort === "az") {
      const collator = new Intl.Collator("pl", { numeric: true, sensitivity: "base" });
      sortedTags.sort((a, b) => {
        const charA = Array.from(a[0])[0] || "";
        const charB = Array.from(b[0])[0] || "";
        const isLetterA = /^\p{L}$/u.test(charA);
        const isLetterB = /^\p{L}$/u.test(charB);
        if (!isLetterA && isLetterB)
          return -1;
        if (isLetterA && !isLetterB)
          return 1;
        return collator.compare(a[0], b[0]);
      });
      let currentHeader = "";
      for (const [tag, count] of sortedTags) {
        const firstChar = (Array.from(tag)[0] || "").toUpperCase();
        const isLetter = /^\p{L}$/u.test(firstChar);
        const headerToUse = isLetter ? firstChar : "OTHER";
        if (headerToUse !== currentHeader) {
          currentHeader = headerToUse;
          if (currentHeader !== "OTHER") {
            const letterEl = this.tagContainer.createSpan({ cls: "flat-tag-letter" });
            letterEl.setText(currentHeader);
          }
        }
        this.createTagElement(tag, count, this.tagContainer);
      }
    } else {
      sortedTags.sort((a, b) => {
        if (b[1] !== a[1])
          return b[1] - a[1];
        return a[0].localeCompare(b[0], "pl");
      });
      sortedTags.forEach(([tag, count]) => this.createTagElement(tag, count, this.tagContainer));
    }
  }
  createTagElement(tag, count, parentEl) {
    var _a;
    const tagEl = parentEl.createSpan({ cls: "flat-tag" });
    if (this.selectedTags.has(tag))
      tagEl.addClass("flat-tag-selected");
    else if (this.excludedTags.has(tag))
      tagEl.addClass("flat-tag-excluded");
    if (((_a = this.plugin.settings.pinnedTags) != null ? _a : []).includes(tag))
      tagEl.addClass("flat-tag-pinned");
    tagEl.setText(`#${tag} (${count})`);
    tagEl.style.userSelect = "none";
    tagEl.style.webkitUserSelect = "none";
    const handleTagInteraction = async (isMultiSelect, isExclude, isPin) => {
      var _a2;
      if (isPin) {
        const list = (_a2 = this.plugin.settings.pinnedTags) != null ? _a2 : [];
        this.plugin.settings.pinnedTags = list.includes(tag) ? list.filter((t) => t !== tag) : [...list, tag];
        await this.plugin.saveSettings();
        this.renderTags();
        return;
      }
      if (isExclude) {
        if (this.excludedTags.has(tag))
          this.excludedTags.delete(tag);
        else {
          this.excludedTags.add(tag);
          this.selectedTags.delete(tag);
        }
      } else if (isMultiSelect) {
        if (this.selectedTags.has(tag))
          this.selectedTags.delete(tag);
        else {
          this.selectedTags.add(tag);
          this.excludedTags.delete(tag);
        }
      } else {
        if (this.selectedTags.size === 1 && this.selectedTags.has(tag))
          this.selectedTags.clear();
        else {
          this.selectedTags.clear();
          this.excludedTags.clear();
          this.selectedTags.add(tag);
        }
      }
      if (this.selectedTags.has(tag)) {
        tagEl.addClass("flat-tag-selected");
        tagEl.removeClass("flat-tag-excluded");
      } else if (this.excludedTags.has(tag)) {
        tagEl.addClass("flat-tag-excluded");
        tagEl.removeClass("flat-tag-selected");
      } else {
        tagEl.removeClass("flat-tag-selected");
        tagEl.removeClass("flat-tag-excluded");
      }
      this.renderTags();
      void this.updateSearch();
    };
    let touchHandled = false;
    let touchStartX = 0;
    let touchStartY = 0;
    let isSwiping = false;
    let longPressTriggered = false;
    tagEl.addEventListener("click", (e) => {
      if (touchHandled) {
        touchHandled = false;
        return;
      }
      e.preventDefault();
      void handleTagInteraction(!!(e.ctrlKey || e.metaKey), !!e.shiftKey, !!e.altKey);
    });
    tagEl.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      const menu = new import_obsidian.Menu();
      const isMuted = tag.startsWith("%");
      const actionName = isMuted ? "Global Un-Mute" : "Global Mute";
      const targetTag = isMuted ? tag.slice(1) : `%${tag}`;
      menu.addItem((item) => {
        item.setTitle(`${actionName} to #${targetTag}`).setIcon("alert-triangle").onClick(() => {
          new GlobalMuteConfirmModal(this.app, tag, async () => {
            await this.executeGlobalMute(tag);
          }).open();
        });
      });
      menu.showAtMouseEvent(e);
    });
    tagEl.addEventListener("touchstart", (e) => {
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      isSwiping = false;
      longPressTriggered = false;
      touchHandled = false;
      if (this.touchTimer)
        window.clearTimeout(this.touchTimer);
      this.touchTimer = window.setTimeout(() => {
        this.touchTimer = null;
        if (!isSwiping) {
          longPressTriggered = true;
          touchHandled = true;
          void handleTagInteraction(true, false, false);
        }
      }, 500);
    }, { passive: true });
    tagEl.addEventListener("touchmove", (e) => {
      const touch = e.touches[0];
      const dx = touch.clientX - touchStartX;
      const dy = touch.clientY - touchStartY;
      if (!isSwiping) {
        if (Math.abs(dx) > 10 && Math.abs(dx) > Math.abs(dy)) {
          if (this.touchTimer) {
            window.clearTimeout(this.touchTimer);
            this.touchTimer = null;
          }
          isSwiping = true;
        } else if (Math.abs(dy) > 10) {
          if (this.touchTimer) {
            window.clearTimeout(this.touchTimer);
            this.touchTimer = null;
          }
          return;
        }
      }
      if (isSwiping && dx < 0) {
        e.preventDefault();
        const capped = Math.max(dx, -90);
        tagEl.style.transform = `translateX(${capped}px)`;
        tagEl.style.opacity = String(0.5 + Math.abs(capped) / 90 * 0.5);
      }
    }, { passive: false });
    tagEl.addEventListener("touchend", (e) => {
      const touch = e.changedTouches[0];
      const dx = touch.clientX - touchStartX;
      tagEl.style.transition = "transform 0.2s ease, opacity 0.2s ease";
      tagEl.style.transform = "";
      tagEl.style.opacity = "";
      setTimeout(() => {
        tagEl.style.transition = "";
      }, 220);
      if (isSwiping) {
        isSwiping = false;
        touchHandled = true;
        if (dx <= -60)
          void handleTagInteraction(false, false, true);
        return;
      }
      if (longPressTriggered) {
        longPressTriggered = false;
        return;
      }
      if (this.touchTimer) {
        window.clearTimeout(this.touchTimer);
        this.touchTimer = null;
        touchHandled = true;
        void handleTagInteraction(false, false, false);
      }
    }, { passive: true });
    tagEl.addEventListener("touchcancel", () => {
      isSwiping = false;
      longPressTriggered = false;
      touchHandled = false;
      if (this.touchTimer) {
        window.clearTimeout(this.touchTimer);
        this.touchTimer = null;
      }
      tagEl.style.transition = "transform 0.2s ease, opacity 0.2s ease";
      tagEl.style.transform = "";
      tagEl.style.opacity = "";
      setTimeout(() => {
        tagEl.style.transition = "";
      }, 220);
    }, { passive: true });
  }
  // ── Execute Global Mute logic ───────────────────────────────────────────
  async executeGlobalMute(tag) {
    const isCurrentlyMuted = tag.startsWith("%");
    const targetTagWord = isCurrentlyMuted ? tag.slice(1) : `%${tag}`;
    const escapedTag = tag.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const tagRegex = new RegExp(`#${escapedTag}(?![\\p{L}\\p{N}_\\-%])`, "gu");
    let filesModified = 0;
    const filesToProcess = [];
    this.tagsByFile.forEach((tagsArr, filePath) => {
      if (tagsArr.includes(tag)) {
        filesToProcess.push(filePath);
      }
    });
    new import_obsidian.Notice(`Globally replacing #${tag}...`);
    for (const filePath of filesToProcess) {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian.TFile) {
        await this.app.vault.process(file, (data) => {
          const newData = data.replace(tagRegex, `#${targetTagWord}`);
          if (data !== newData)
            filesModified++;
          return newData;
        });
      }
    }
    new import_obsidian.Notice(`Success: Replaced #${tag} with #${targetTagWord} in ${filesModified} file(s).`);
    this.selectedTags.delete(tag);
    this.excludedTags.delete(tag);
    this.renderTags();
    void this.updateSearch();
  }
  // ─────────────────────────────────────────────────────────────────────────────
  async getFilteredTagsAsync() {
    var _a, _b, _c;
    let filtered = /* @__PURE__ */ new Map();
    if (this.selectedTags.size === 0) {
      filtered = new Map(this.allTags);
    } else {
      const selectedArr = Array.from(this.selectedTags);
      const matchingFiles = [];
      this.tagsByFile.forEach((tagsArr, filePath) => {
        if (selectedArr.every((t) => tagsArr.includes(t)))
          matchingFiles.push(filePath);
      });
      if (this.searchMode === "note") {
        for (const filePath of matchingFiles) {
          const tags = this.tagsByFile.get(filePath);
          if (!tags)
            continue;
          for (const t of tags)
            filtered.set(t, (filtered.get(t) || 0) + 1);
        }
      } else {
        for (const filePath of matchingFiles) {
          const file = this.app.vault.getAbstractFileByPath(filePath);
          if (!(file instanceof import_obsidian.TFile))
            continue;
          const content = await this.app.vault.cachedRead(file);
          const lines = content.split(/\r?\n/);
          for (const line of lines) {
            const lower = line.toLowerCase();
            if (this.searchMode === "task" && !lower.includes("- ["))
              continue;
            if (this.searchMode === "task-todo" && !lower.includes("- [ ]"))
              continue;
            if (this.searchMode === "task-done" && !lower.includes("- [x"))
              continue;
            const lineTags = /* @__PURE__ */ new Set();
            const tagRegex = /#([^\s#]+)/g;
            let m;
            while ((m = tagRegex.exec(lower)) !== null)
              lineTags.add(m[1]);
            const hasAll = selectedArr.every(
              (sel) => Array.from(lineTags).some((t) => t.toLowerCase() === sel.toLowerCase())
            );
            if (!hasAll)
              continue;
            for (const t of lineTags)
              filtered.set(t, (filtered.get(t) || 0) + 1);
          }
        }
      }
    }
    for (const t of this.selectedTags)
      if (!filtered.has(t))
        filtered.set(t, this.allTags.get(t) || 0);
    for (const t of this.excludedTags)
      if (!filtered.has(t))
        filtered.set(t, this.allTags.get(t) || 0);
    const cutoffEnabled = (_a = this.plugin.settings.frequencyCutoffEnabled) != null ? _a : false;
    const cutoff = cutoffEnabled ? (_b = this.plugin.settings.frequencyCutoff) != null ? _b : 0 : 0;
    const pinned = new Set((_c = this.plugin.settings.pinnedTags) != null ? _c : []);
    if (cutoff > 0) {
      const next = /* @__PURE__ */ new Map();
      filtered.forEach((count, tag) => {
        if (count >= cutoff || this.selectedTags.has(tag) || pinned.has(tag))
          next.set(tag, count);
      });
      filtered = next;
    }
    if (this.tagSearchText) {
      const q = this.tagSearchText.toLowerCase();
      const next = /* @__PURE__ */ new Map();
      filtered.forEach((count, tag) => {
        if (tag.toLowerCase().includes(q) || this.selectedTags.has(tag) || this.excludedTags.has(tag))
          next.set(tag, count);
      });
      filtered = next;
    }
    return filtered;
  }
  async updateSearch(options) {
    var _a, _b, _c;
    const workspace = this.app.workspace;
    const prevLeaf = workspace.activeLeaf;
    const isTouchContext = import_obsidian.Platform.isMobile || this.lastInteractionWasTouch;
    const revealSearch = (_a = options == null ? void 0 : options.revealSearch) != null ? _a : !isTouchContext;
    const createIfMissing = (_b = options == null ? void 0 : options.createIfMissing) != null ? _b : !isTouchContext;
    let searchLeaf = workspace.getLeavesOfType("search")[0];
    if (!searchLeaf && createIfMissing) {
      const rightLeaf = workspace.getRightLeaf(true);
      if (rightLeaf) {
        searchLeaf = rightLeaf;
        await searchLeaf.setViewState({ type: "search", active: false });
      }
    }
    if (searchLeaf && revealSearch)
      workspace.revealLeaf(searchLeaf);
    if (prevLeaf)
      workspace.setActiveLeaf(prevLeaf, { focus: true });
    this.lastInteractionWasTouch = false;
    if (!searchLeaf)
      return;
    const selected = Array.from(this.selectedTags);
    const excluded = Array.from(this.excludedTags);
    const searchView = searchLeaf.view;
    if (selected.length === 0 && excluded.length === 0) {
      const clearBtn = (_c = searchView == null ? void 0 : searchView.containerEl) == null ? void 0 : _c.querySelector(".search-input-clear-button");
      if (clearBtn)
        clearBtn.dispatchEvent(new MouseEvent("click", { bubbles: true, cancelable: false }));
      else if (typeof (searchView == null ? void 0 : searchView.setQuery) === "function")
        searchView.setQuery("");
      return;
    }
    let query = "";
    if (this.searchMode === "note") {
      query = [
        ...selected.map((t) => `tag:#${t}`),
        ...excluded.map((t) => `-tag:#${t}`)
      ].join(" ");
    } else {
      const prefix = this.searchMode === "line" ? "line:(" : this.searchMode === "task" ? "task:(" : this.searchMode === "task-todo" ? "task-todo:(" : "task-done:(";
      const body = [
        ...selected.map((t) => `#${t}`),
        ...excluded.map((t) => `-#${t}`)
      ].join(" ");
      query = `${prefix}${body})`;
    }
    if (typeof (searchView == null ? void 0 : searchView.setQuery) === "function")
      searchView.setQuery(query);
  }
  getFileTags(file) {
    var _a;
    const cache = this.app.metadataCache.getFileCache(file);
    if (!cache)
      return [];
    const tags = [];
    if (cache.tags)
      cache.tags.forEach((t) => tags.push(t.tag.replace(/^#/, "")));
    const fm = (_a = cache.frontmatter) == null ? void 0 : _a.tags;
    if (typeof fm === "string") {
      fm.split(",").map((s) => s.trim()).filter(Boolean).forEach((t) => tags.push(t.replace(/^#/, "")));
    } else if (Array.isArray(fm)) {
      fm.forEach((t) => {
        if (t)
          tags.push(String(t).replace(/^#/, ""));
      });
    }
    return Array.from(new Set(tags));
  }
  syncCutoffControlsFromSettings() {
    var _a, _b;
    const enabled = (_a = this.plugin.settings.frequencyCutoffEnabled) != null ? _a : false;
    const cutoff = (_b = this.plugin.settings.frequencyCutoff) != null ? _b : 0;
    this.cutoffInput.value = String(cutoff);
    this.cutoffInput.disabled = !enabled;
    this.cutoffToggleBtn.toggleClass("is-enabled", enabled);
    this.cutoffToggleBtn.toggleClass("is-disabled", !enabled);
    (0, import_obsidian.setIcon)(this.cutoffToggleBtn, enabled ? "eye" : "eye-off");
  }
  updateModeUI(skipSearch = false) {
    this.sortAzBtn.toggleClass("is-active", this.currentSort === "az");
    this.sortCountBtn.toggleClass("is-active", this.currentSort === "count");
    this.scopeBtn.removeClass("is-active");
    this.taskBtn.removeClass("is-active");
    if (this.searchMode === "note") {
      this.scopeBtn.setText("NOTE");
      this.scopeBtn.addClass("is-active");
    } else if (this.searchMode === "line") {
      this.scopeBtn.setText("LINE");
      this.scopeBtn.addClass("is-active");
    } else if (this.searchMode === "task") {
      this.taskBtn.setText("TASK-ALL");
      this.taskBtn.addClass("is-active");
    } else if (this.searchMode === "task-todo") {
      this.taskBtn.setText("TASK-TODO");
      this.taskBtn.addClass("is-active");
    } else if (this.searchMode === "task-done") {
      this.taskBtn.setText("TASK-DONE");
      this.taskBtn.addClass("is-active");
    }
    if (["note", "line"].includes(this.searchMode)) {
      if (!["TASK-ALL", "TASK-TODO", "TASK-DONE"].includes(this.taskBtn.innerText))
        this.taskBtn.setText("TASK-ALL");
    } else {
      if (!["NOTE", "LINE"].includes(this.scopeBtn.innerText))
        this.scopeBtn.setText("NOTE");
    }
    if (!skipSearch)
      void this.updateSearch();
    if (this.tagContainer)
      this.renderTags();
  }
  toggleScopeMode() {
    if (["note", "line"].includes(this.searchMode))
      this.searchMode = this.searchMode === "note" ? "line" : "note";
    else
      this.searchMode = this.scopeBtn.innerText === "LINE" ? "line" : "note";
    this.updateModeUI();
  }
  toggleTaskMode() {
    if (this.searchMode === "task")
      this.searchMode = "task-todo";
    else if (this.searchMode === "task-todo")
      this.searchMode = "task-done";
    else if (this.searchMode === "task-done")
      this.searchMode = "task";
    else
      this.searchMode = "task";
    this.updateModeUI();
  }
  toggleSort() {
    this.currentSort = this.currentSort === "az" ? "count" : "az";
    this.updateModeUI(true);
  }
  clearTagSelections() {
    this.selectedTags.clear();
    this.excludedTags.clear();
    this.renderTags();
    void this.updateSearch({ revealSearch: false, createIfMissing: false });
  }
  clearSearchBox() {
    const searchBox = this.contentEl.querySelector(".flat-tag-search-input");
    if (searchBox)
      searchBox.value = "";
    this.tagSearchText = "";
    this.renderTags();
  }
  selectSingleTag(tag) {
    this.selectedTags.clear();
    this.excludedTags.clear();
    const cleanTag = tag.replace(/^#/, "");
    this.selectedTags.add(cleanTag);
    this.renderTags();
    void this.updateSearch({ revealSearch: true, createIfMissing: true });
  }
};

// styles.ts
var getStyles = () => {
  return `
.workspace-split.mod-root .view-content.flat-tag-view {
	display: flex;
	flex-direction: column;
	justify-content: flex-start;
	align-items: stretch;
	height: 100%;
	padding: 0;
	margin: 0;
}

.flat-tag-container {
	display: flex;
	flex-direction: column;
	align-items: flex-start;
	justify-content: flex-start;
	width: 100%;
	height: 100%;
	box-sizing: border-box;
	padding: 0;
	margin: 0;
}

.flat-tag-sort-container {
	display: flex;
	justify-content: space-between;
	align-items: center;
	flex-shrink: 0;
	padding: 8px;
	background-color: var(--background-primary);
	border-bottom: 1px solid var(--background-modifier-border);
	width: 100%;
	flex-wrap: wrap;
	gap: 8px;
}

.flat-tag-buttons-section {
	display: flex;
	gap: 6px;
	align-items: center;
	flex-wrap: wrap;
}

.flat-tag-mode-button {
	cursor: pointer;
	padding: 4px 10px;
	font-size: 0.8em;
	font-weight: 500;
	border-radius: var(--radius-s);
	color: var(--text-muted);
	background-color: var(--background-modifier-form-field);
	border: 1px solid var(--background-modifier-border);
	transition: all 0.15s ease-in-out;
	user-select: none;
	display: flex;
	align-items: center;
	justify-content: center;
	min-width: 65px;
}

.flat-tag-mode-button:hover {
	color: var(--text-normal);
	background-color: var(--background-modifier-hover);
	border-color: var(--background-modifier-border-hover);
}

.flat-tag-mode-button.is-active {
	background-color: var(--interactive-accent);
	color: var(--text-on-accent);
	border-color: var(--interactive-accent);
	box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
}

.flat-tag-mode-button.is-active:hover {
	background-color: var(--interactive-accent-hover);
	border-color: var(--interactive-accent-hover);
}

.flat-tag-search-section {
	display: flex;
	align-items: center;
	gap: 4px;
	margin-left: auto;
	background-color: var(--background-secondary);
	border-radius: 4px;
	padding: 2px 8px;
	flex-grow: 1;
	max-width: 220px;
}

.flat-tag-search-input {
	background: transparent;
	border: none;
	color: var(--text-normal);
	width: 100%;
	height: 24px;
	font-size: 0.9em;
}

.flat-tag-search-input:focus {
	outline: none;
	box-shadow: none;
}

.flat-tag-search-clear-button {
	cursor: pointer;
	color: var(--text-muted);
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 0.8em;
}

.flat-tag-search-clear-button:hover {
	color: var(--text-normal);
}

.flat-tag-sort-button,
.flat-tag-clear-button {
	cursor: pointer;
	padding: 4px;
	border-radius: 4px;
	display: flex;
	align-items: center;
	justify-content: center;
}

.flat-tag-sort-button:hover,
.flat-tag-clear-button:hover {
	background-color: var(--interactive-hover);
}

.flat-tag-sort-button.is-active {
	background-color: var(--interactive-accent);
	color: var(--text-on-accent);
	box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
}

.flat-tag-sort-button.is-active:hover {
	background-color: var(--interactive-accent-hover);
}

/* Cutoff controls */
.flat-tag-cutoff-spacer {
	flex: 0 0 8px;
	width: 8px;
	height: 1px;
}

.flat-tag-cutoff-section {
	display: flex;
	align-items: center;
	gap: 6px;
	padding: 2px 8px;
	border-radius: var(--radius-s);
	border: 1px solid var(--background-modifier-border);
	background: linear-gradient(180deg, var(--background-secondary) 0%, var(--background-primary) 100%);
	box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
	height: 28px;
}

.flat-tag-cutoff-toggle {
	cursor: pointer;
	display: inline-flex;
	align-items: center;
	justify-content: center;
	color: var(--text-muted);
	padding: 2px;
	border-radius: var(--radius-s);
}

.flat-tag-cutoff-toggle:hover {
	color: var(--text-normal);
	background-color: var(--background-modifier-hover);
}

.flat-tag-cutoff-toggle.is-enabled {
	color: var(--interactive-accent);
}

.flat-tag-cutoff-toggle.is-disabled {
	opacity: 0.7;
}

.flat-tag-cutoff-input {
	width: 52px;
	height: 22px;
	border: none;
	background: transparent;
	padding: 0;
	margin: 0;
	text-align: center;
	font-size: 0.9em;
	color: var(--text-normal);
}

.flat-tag-cutoff-input:focus {
	outline: none;
	box-shadow: none;
}

.flat-tag-cutoff-input:disabled {
	color: var(--text-faint);
	cursor: not-allowed;
}

.flat-tag-list {
	display: flex;
	flex-wrap: wrap;
	align-content: flex-start;
	overflow-y: auto;
	flex: 1;
	line-height: 1.5em;
	padding: 8px;
	width: 100%;
}

.flat-tag {
	display: inline-block;
	padding: 2px 6px;
	margin: 2px;
	border-radius: 4px;
	cursor: pointer;
	background-color: var(--tag-background);
	color: var(--tag-color);
	transition: background-color 0.1s;
}

.flat-tag:hover {
	background-color: var(--tag-background-hover);
}

.flat-tag-selected {
	font-weight: bold;
	background-color: var(--interactive-accent);
	color: var(--text-on-accent);
}

.flat-tag-excluded {
	font-weight: bold;
	background-color: var(--color-red);
	color: var(--text-on-accent);
}

.flat-tag-letter {
	display: inline-flex;
	font-weight: bold;
	font-size: 1.2em;
	margin: 2px;
	padding: 2px 6px;
	border-radius: 4px;
	background-color: var(--background-secondary);
	color: var(--text-normal);
	align-items: center;
	justify-content: center;
	min-width: 24px;
}

.flat-tag-pinned-section {
	width: 100%;
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	background-color: color-mix(in srgb, var(--interactive-accent) 10%, var(--background-primary));
	border: 1px solid color-mix(in srgb, var(--interactive-accent) 25%, transparent);
	padding: 4px;
	border-radius: var(--radius-s);
	margin-bottom: 4px;
}

.flat-tag-separator {
	width: 100%;
	height: 1px;
	background-color: var(--background-modifier-border);
	margin: 4px 0 8px 0;
}

.flat-tag-pinned {
	border: 1px solid var(--interactive-accent);
}
`;
};

// settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  pinnedTags: [],
  frequencyCutoff: 0,
  frequencyCutoffEnabled: false,
  altClickTagMode: "start-line",
  showPlacementInStatusBar: true,
  mobileLongPressEnabled: true,
  mobileLongPressMs: 1e3
};
var FlatTagSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Alt-click tag placement").setDesc("When creating a tag, where it should go.").addDropdown(
      (dd) => dd.addOption("start-line", "Put tag at start of line").addOption("in-place", "Turn word into tag in place").addOption("end-line", "Put tag at end of line").setValue(this.plugin.settings.altClickTagMode).onChange(async (value) => {
        this.plugin.settings.altClickTagMode = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Show placement of newly created tags in status bar").setDesc("Displays SOL / INP / EOL in the Obsidian status bar.").addToggle(
      (t) => t.setValue(this.plugin.settings.showPlacementInStatusBar).onChange(async (val) => {
        this.plugin.settings.showPlacementInStatusBar = val;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Frequency cutoff").setDesc("Hide tags that appear fewer times than this number in the vault.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.frequencyCutoffEnabled).onChange(async (value) => {
        this.plugin.settings.frequencyCutoffEnabled = value;
        await this.plugin.saveSettings();
      })
    ).addText(
      (text) => text.setPlaceholder("0").setValue(this.plugin.settings.frequencyCutoff.toString()).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        if (!isNaN(parsed) && parsed >= 0) {
          this.plugin.settings.frequencyCutoff = parsed;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Clear pinned tags").setDesc("Removes all pinned tags from the top of the flat tag list.").addButton(
      (btn) => btn.setButtonText("Clear pinned").onClick(async () => {
        this.plugin.settings.pinnedTags = [];
        await this.plugin.saveSettings();
      })
    );
  }
};

// main.ts
var FlatTagPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.statusBarEl = null;
  }
  async onload() {
    await this.loadSettings();
    this.registerView(VIEW_TYPE, (leaf) => new FlatTagView(leaf, this));
    this.addRibbonIcon("tag", "Open Flat Tags", () => void this.activateView());
    this.addSettingTab(new FlatTagSettingTab(this.app, this));
    this.addCommand({
      id: "open-flat-tags",
      name: "Open Flat Tags",
      callback: () => void this.activateView()
    });
    this.addCommand({
      id: "toggle-flat-tag-sort",
      name: "Toggle Flat Tag Sort (A-Z/Usage)",
      callback: () => {
        var _a;
        const view = (_a = this.app.workspace.getLeavesOfType(VIEW_TYPE)[0]) == null ? void 0 : _a.view;
        if (view && typeof view.toggleSort === "function")
          view.toggleSort();
      }
    });
    this.addCommand({
      id: "clear-flat-tag-selections",
      name: "Clear Flat Tag Selections",
      callback: () => {
        var _a;
        const view = (_a = this.app.workspace.getLeavesOfType(VIEW_TYPE)[0]) == null ? void 0 : _a.view;
        if (view && typeof view.clearTagSelections === "function")
          view.clearTagSelections();
      }
    });
    this.addCommand({
      id: "clear-flat-tag-search",
      name: "Clear Flat Tag Search Box",
      callback: () => {
        var _a;
        const view = (_a = this.app.workspace.getLeavesOfType(VIEW_TYPE)[0]) == null ? void 0 : _a.view;
        if (view && typeof view.clearSearchBox === "function")
          view.clearSearchBox();
      }
    });
    this.addCommand({
      id: "toggle-flat-tag-scope-mode",
      name: "Toggle Flat Tag Mode (Note/Line)",
      callback: () => {
        var _a;
        const view = (_a = this.app.workspace.getLeavesOfType(VIEW_TYPE)[0]) == null ? void 0 : _a.view;
        if (view && typeof view.toggleScopeMode === "function")
          view.toggleScopeMode();
      }
    });
    this.addCommand({
      id: "toggle-flat-tag-task-mode",
      name: "Cycle Flat Tag Task Mode (All/Todo/Done)",
      callback: () => {
        var _a;
        const view = (_a = this.app.workspace.getLeavesOfType(VIEW_TYPE)[0]) == null ? void 0 : _a.view;
        if (view && typeof view.toggleTaskMode === "function")
          view.toggleTaskMode();
      }
    });
    this.addCommand({
      id: "cycle-flat-tag-placement",
      name: "Cycle Tag Placement (SOL / INP / EOL)",
      callback: () => void this.cycleTagPlacement()
    });
    this.addCommand({
      id: "set-flat-tag-placement-sol",
      name: "Set Tag Placement to Start of Line (SOL)",
      callback: async () => {
        this.settings.altClickTagMode = "start-line";
        await this.saveSettings();
        new import_obsidian3.Notice("Tag placement: Start of line");
      }
    });
    this.addCommand({
      id: "set-flat-tag-placement-inp",
      name: "Set Tag Placement to In Place (INP)",
      callback: async () => {
        this.settings.altClickTagMode = "in-place";
        await this.saveSettings();
        new import_obsidian3.Notice("Tag placement: In place");
      }
    });
    this.addCommand({
      id: "set-flat-tag-placement-eol",
      name: "Set Tag Placement to End of Line (EOL)",
      callback: async () => {
        this.settings.altClickTagMode = "end-line";
        await this.saveSettings();
        new import_obsidian3.Notice("Tag placement: End of line");
      }
    });
    this.addStyle();
    this.statusBarEl = this.addStatusBarItem();
    this.updateStatusBar();
    this.statusBarEl.addClass("mod-clickable");
    this.statusBarEl.addEventListener("click", () => void this.cycleTagPlacement());
    this.registerDomEvent(document, "click", (evt) => {
      if (!evt.altKey)
        return;
      if (evt.shiftKey && (evt.ctrlKey || evt.metaKey)) {
        evt.preventDefault();
        evt.stopPropagation();
        void this.handleEditorTrigger({ kind: "local-mute", mouseEvent: evt });
        return;
      }
      if (!evt.shiftKey && (evt.ctrlKey || evt.metaKey)) {
        evt.preventDefault();
        evt.stopPropagation();
        void this.handleEditorTrigger({ kind: "drill-down", mouseEvent: evt });
        return;
      }
      if (!evt.shiftKey && !evt.ctrlKey && !evt.metaKey) {
        evt.preventDefault();
        void this.handleEditorTrigger({ kind: "alt-click", mouseEvent: evt });
        return;
      }
    }, { capture: true });
    this.registerMobileLongPress();
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE);
    if (this.statusBarEl) {
      this.statusBarEl.remove();
      this.statusBarEl = null;
    }
  }
  async cycleTagPlacement() {
    const modes = ["start-line", "in-place", "end-line"];
    const current = this.settings.altClickTagMode;
    const next = modes[(modes.indexOf(current) + 1) % modes.length];
    this.settings.altClickTagMode = next;
    await this.saveSettings();
    const labels = {
      "start-line": "Start of line",
      "in-place": "In place",
      "end-line": "End of line"
    };
    new import_obsidian3.Notice(`Tag placement: ${labels[next]}`);
  }
  // ── Status bar ──────────────────────────────────────────────────────────────
  updateStatusBar() {
    var _a, _b;
    if (!this.statusBarEl)
      return;
    const show = (_a = this.settings.showPlacementInStatusBar) != null ? _a : true;
    if (!show) {
      this.statusBarEl.setText("");
      this.statusBarEl.style.display = "none";
      return;
    }
    const labels = {
      "start-line": "SOL",
      "in-place": "INP",
      "end-line": "EOL"
    };
    const modeLabel = (_b = labels[this.settings.altClickTagMode]) != null ? _b : "SOL";
    this.statusBarEl.setText(`#>${modeLabel}`);
    this.statusBarEl.style.display = "";
  }
  // ── Mobile long press ────────────────────────────────────────────────────────
  registerMobileLongPress() {
    if (!import_obsidian3.Platform.isMobile)
      return;
    let timer = null;
    let startX = 0;
    let startY = 0;
    let cancelled = false;
    let longPressArmed = false;
    const clear = () => {
      if (timer)
        window.clearTimeout(timer);
      timer = null;
      longPressArmed = false;
    };
    this.registerDomEvent(
      document,
      "touchstart",
      (evt) => {
        var _a;
        if (!this.settings.mobileLongPressEnabled)
          return;
        if (evt.touches.length !== 1)
          return;
        cancelled = false;
        longPressArmed = false;
        const t = evt.touches[0];
        startX = t.clientX;
        startY = t.clientY;
        clear();
        const ms = Math.max(250, Math.min(5e3, (_a = this.settings.mobileLongPressMs) != null ? _a : 1e3));
        timer = window.setTimeout(() => {
          timer = null;
          if (cancelled)
            return;
          longPressArmed = true;
        }, ms);
      },
      { passive: true }
    );
    this.registerDomEvent(
      document,
      "touchmove",
      (evt) => {
        if (!timer)
          return;
        const t = evt.touches[0];
        const dx = Math.abs(t.clientX - startX);
        const dy = Math.abs(t.clientY - startY);
        if (dx > 12 || dy > 12) {
          cancelled = true;
          clear();
        }
      },
      { passive: true }
    );
    this.registerDomEvent(
      document,
      "touchend",
      () => {
        const shouldFire = longPressArmed && !cancelled;
        clear();
        if (!shouldFire)
          return;
        void this.handleEditorTrigger({ kind: "mobile-long-press" });
      },
      { passive: true }
    );
    this.registerDomEvent(
      document,
      "touchcancel",
      () => {
        cancelled = true;
        clear();
      },
      { passive: true }
    );
  }
  // ── Trigger entry-point ──────────────────────────────────────────────────────
  async handleEditorTrigger(trigger) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!view)
      return;
    const anyView = view;
    if (typeof anyView.getMode === "function" && anyView.getMode() !== "source")
      return;
    const editor = view.editor;
    if (!editor)
      return;
    if (trigger.kind === "mobile-long-press") {
      const sel = editor.getSelection();
      if (!sel || !sel.trim())
        return;
    }
    const candidate = this.getCandidateWithRange(editor, { preferSelection: import_obsidian3.Platform.isMobile });
    if (!candidate)
      return;
    if (trigger.kind === "drill-down") {
      if (candidate.raw.startsWith("#")) {
        await this.activateView();
        setTimeout(() => {
          const ftvLeaf = this.app.workspace.getLeavesOfType(VIEW_TYPE)[0];
          if (ftvLeaf && ftvLeaf.view instanceof FlatTagView) {
            ftvLeaf.view.selectSingleTag(candidate.raw);
          }
        }, 50);
      }
      return;
    }
    if (trigger.kind === "local-mute") {
      if (candidate.raw.startsWith("#") && candidate.range) {
        const currentTag = candidate.raw;
        let newTag = "";
        if (currentTag.startsWith("#%")) {
          newTag = "#" + currentTag.slice(2);
        } else {
          newTag = "#%" + currentTag.slice(1);
        }
        editor.replaceRange(newTag, candidate.range.from, candidate.range.to);
      }
      return;
    }
    if (trigger.kind === "alt-click" || trigger.kind === "mobile-long-press") {
      if (candidate.raw.startsWith("#%")) {
        return;
      }
      if (candidate.raw.startsWith("#")) {
        await this.removeTag(editor, candidate);
      } else {
        await this.createTag(editor, this.settings.altClickTagMode, candidate);
      }
    }
  }
  // ── Candidate resolution ─────────────────────────────────────────────────────
  getSelectionRange(editor) {
    var _a, _b;
    const anyEditor = editor;
    const from = (_a = anyEditor.getCursor) == null ? void 0 : _a.call(anyEditor, "from");
    const to = (_b = anyEditor.getCursor) == null ? void 0 : _b.call(anyEditor, "to");
    if (!from || !to)
      return null;
    if (from.line === to.line && from.ch === to.ch)
      return null;
    if (from.line > to.line || from.line === to.line && from.ch > to.ch)
      return { from: to, to: from };
    return { from, to };
  }
  buildSelCandidate(editor, sel, r) {
    const raw = sel.trim();
    if (!raw.startsWith("#") && r.from.ch > 0) {
      const lineText = editor.getLine(r.from.line);
      if (lineText.charAt(r.from.ch - 1) === "#") {
        return {
          raw: "#" + raw,
          range: { from: { line: r.from.line, ch: r.from.ch - 1 }, to: r.to }
        };
      }
    }
    return { raw, range: r };
  }
  getCandidateWithRange(editor, opts) {
    var _a;
    const preferSelection = (_a = opts == null ? void 0 : opts.preferSelection) != null ? _a : true;
    const sel = editor.getSelection();
    const selRange = this.getSelectionRange(editor);
    if (preferSelection && sel && sel.trim() && !/[\r\n]/.test(sel) && selRange) {
      return this.buildSelCandidate(editor, sel, selRange);
    }
    const token = this.getTokenAtCursor(editor);
    if (token)
      return token;
    if (!preferSelection && sel && sel.trim() && !/[\r\n]/.test(sel) && selRange) {
      return this.buildSelCandidate(editor, sel, selRange);
    }
    return null;
  }
  getTokenAtCursor(editor) {
    var _a;
    const cursor = editor.getCursor();
    const lineText = (_a = editor.getLine(cursor.line)) != null ? _a : "";
    if (!lineText)
      return null;
    const isBodyChar = (ch) => /[\p{L}\p{N}_\-%]/u.test(ch);
    let i = cursor.ch;
    if (i >= lineText.length)
      i = lineText.length - 1;
    if (i < 0)
      return null;
    const cur = lineText.charAt(i);
    if (cur === "#") {
      let end = i + 1;
      while (end < lineText.length && isBodyChar(lineText.charAt(end)))
        end++;
      if (end === i + 1)
        return null;
      return {
        raw: lineText.slice(i, end),
        range: { from: { line: cursor.line, ch: i }, to: { line: cursor.line, ch: end } }
      };
    }
    if (isBodyChar(cur)) {
      return this.wordRangeAt(cursor.line, lineText, i);
    }
    if (i > 0 && isBodyChar(lineText.charAt(i - 1))) {
      return this.wordRangeAt(cursor.line, lineText, i - 1);
    }
    return null;
  }
  wordRangeAt(line, lineText, i) {
    const isBodyChar = (ch) => /[\p{L}\p{N}_\-%]/u.test(ch);
    let start = i;
    while (start > 0 && isBodyChar(lineText.charAt(start - 1)))
      start--;
    const hashStart = start > 0 && lineText.charAt(start - 1) === "#" ? start - 1 : start;
    let end = i + 1;
    while (end < lineText.length && isBodyChar(lineText.charAt(end)))
      end++;
    const raw = lineText.slice(hashStart, end);
    if (!raw.trim())
      return null;
    return {
      raw,
      range: { from: { line, ch: hashStart }, to: { line, ch: end } }
    };
  }
  // ── Validation ───────────────────────────────────────────────────────────────
  hasForbiddenChars(raw) {
    const s = raw.trim();
    if (!s)
      return true;
    const body = s.startsWith("#") ? s.slice(1) : s;
    if (body.includes("#"))
      return true;
    return /[!@$^&*()+= <>,./?`~]/.test(body);
  }
  normalizeCandidate(raw) {
    let t = raw.trim();
    if (!t)
      return null;
    if (this.hasForbiddenChars(t))
      return null;
    if (t.startsWith("#"))
      t = t.slice(1);
    if (!t)
      return null;
    if (/^\d+$/.test(t) || t === "%")
      return null;
    if (/\s/.test(t))
      return null;
    return t;
  }
  // ── Tag helpers ──────────────────────────────────────────────────────────────
  tagTokenForPlacement(candidate, mode) {
    const text = mode === "start-line" || mode === "end-line" ? candidate.toLowerCase() : candidate;
    return `#${text}`;
  }
  sortTags(tokens) {
    const uniq = [];
    const seen = /* @__PURE__ */ new Set();
    for (const t of tokens) {
      const key = t.replace(/^#/, "").toLowerCase();
      if (seen.has(key))
        continue;
      seen.add(key);
      uniq.push(t);
    }
    return uniq.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase(), "pl"));
  }
  // ── Line parsing ─────────────────────────────────────────────────────────────
  parseLeadingTags(lineText) {
    var _a, _b, _c;
    const indent = ((_a = lineText.match(/^\s*/)) != null ? _a : [""])[0];
    const rest = lineText.slice(indent.length);
    const m = rest.match(/^((?:#[^\s#]+\s+)*)/);
    const tagBlock = (_b = m == null ? void 0 : m[1]) != null ? _b : "";
    const tags = (_c = tagBlock.match(/#[^\s#]+/g)) != null ? _c : [];
    const after = rest.slice(tagBlock.length);
    return { indent, tagBlock, tags, after };
  }
  splitBlockIdSuffix(lineText) {
    var _a;
    const trailingWs = ((_a = lineText.match(/\s*$/)) != null ? _a : [""])[0];
    const noTrail = lineText.slice(0, lineText.length - trailingWs.length);
    const m = noTrail.match(/(\s\^[\p{L}\p{N}_-]+)$/u);
    if (!m)
      return { core: noTrail, blockId: "", trailingWs };
    const blockWithSpace = m[1];
    const core = noTrail.slice(0, noTrail.length - blockWithSpace.length);
    const blockId = blockWithSpace.trim();
    return { core, blockId, trailingWs };
  }
  parseTrailingTags(coreText) {
    var _a;
    const m = coreText.match(/(\s+(?:#[^\s#]+\s*)+)$/);
    if (!m)
      return { before: coreText, tags: [] };
    const tagBlock = m[1];
    const tags = (_a = tagBlock.match(/#[^\s#]+/g)) != null ? _a : [];
    const before = coreText.slice(0, coreText.length - tagBlock.length);
    return { before, tags };
  }
  buildLineWithLeading(indent, tags, after) {
    const afterClean = after.replace(/^\s+/, "");
    const tagBlock = tags.join(" ");
    const body = tagBlock ? afterClean ? `${tagBlock} ${afterClean}` : tagBlock : afterClean;
    return `${indent}${body}`;
  }
  buildLineWithTrailing(before, tags, blockId, trailingWs) {
    const beforeClean = before.replace(/\s+$/, "");
    const tagBlock = tags.join(" ");
    const parts = [];
    if (beforeClean)
      parts.push(beforeClean);
    if (tagBlock)
      parts.push(tagBlock);
    if (blockId)
      parts.push(blockId);
    return `${parts.join(" ")}${trailingWs}`;
  }
  // ── Create / Remove ─────────────────────────────────────────────────────────
  async createTag(editor, mode, candidate) {
    const normalized = this.normalizeCandidate(candidate.raw);
    if (!normalized)
      return;
    const tagToken = this.tagTokenForPlacement(normalized, mode);
    if (mode === "in-place") {
      if (candidate.range)
        editor.replaceRange(tagToken, candidate.range.from, candidate.range.to);
      else
        editor.replaceSelection(tagToken);
      return;
    }
    const line = editor.getCursor().line;
    const lineText = editor.getLine(line);
    if (mode === "start-line") {
      const lead = this.parseLeadingTags(lineText);
      const next2 = this.sortTags([...lead.tags, tagToken]);
      const newLine2 = this.buildLineWithLeading(lead.indent, next2, lead.after);
      editor.replaceRange(newLine2, { line, ch: 0 }, { line, ch: lineText.length });
      return;
    }
    const split = this.splitBlockIdSuffix(lineText);
    const trail = this.parseTrailingTags(split.core);
    const next = this.sortTags([...trail.tags, tagToken]);
    const newLine = this.buildLineWithTrailing(trail.before, next, split.blockId, split.trailingWs);
    editor.replaceRange(newLine, { line, ch: 0 }, { line, ch: lineText.length });
  }
  async removeTag(editor, candidate) {
    var _a, _b, _c, _d, _e, _f;
    const normalized = this.normalizeCandidate(candidate.raw);
    if (!normalized)
      return;
    const key = normalized.toLowerCase();
    const cursor = editor.getCursor();
    const line = (_c = (_b = (_a = candidate.range) == null ? void 0 : _a.from) == null ? void 0 : _b.line) != null ? _c : cursor.line;
    if (candidate.range && (candidate.range.from.line !== line || candidate.range.to.line !== line))
      return;
    const lineText = editor.getLine(line);
    const ch = (_f = (_e = (_d = candidate.range) == null ? void 0 : _d.from) == null ? void 0 : _e.ch) != null ? _f : cursor.ch;
    const lead = this.parseLeadingTags(lineText);
    const split = this.splitBlockIdSuffix(lineText);
    const trail = this.parseTrailingTags(split.core);
    const leadStart = 0;
    const leadEnd = lead.indent.length + lead.tagBlock.length;
    const trailStart = trail.before.length;
    const trailEnd = split.core.length;
    const inLeading = ch >= leadStart && ch < leadEnd;
    const inTrailing = ch >= trailStart && ch < trailEnd;
    if (inLeading) {
      const leadHas = lead.tags.some((t) => t.replace(/^#/, "").toLowerCase() === key);
      if (leadHas) {
        const kept = lead.tags.filter((t) => t.replace(/^#/, "").toLowerCase() !== key);
        const newLine = this.buildLineWithLeading(lead.indent, kept, lead.after);
        editor.replaceRange(newLine, { line, ch: 0 }, { line, ch: lineText.length });
        return;
      }
    }
    if (inTrailing) {
      const trailHas = trail.tags.some((t) => t.replace(/^#/, "").toLowerCase() === key);
      if (trailHas) {
        const kept = trail.tags.filter((t) => t.replace(/^#/, "").toLowerCase() !== key);
        const newLine = this.buildLineWithTrailing(trail.before, kept, split.blockId, split.trailingWs);
        editor.replaceRange(newLine, { line, ch: 0 }, { line, ch: lineText.length });
        return;
      }
    }
    if (candidate.range) {
      const fromCh = candidate.range.from.ch;
      const toCh = candidate.range.to.ch;
      const selected = editor.getRange(candidate.range.from, candidate.range.to);
      if (selected && selected.startsWith("#")) {
        const beforeTag = lineText.slice(0, fromCh);
        const afterTag = lineText.slice(toCh);
        if (beforeTag.endsWith("[") && afterTag.startsWith(`](${selected})`)) {
          let expandedFrom = fromCh - 1;
          let expandedTo = toCh + 3 + selected.length;
          if (expandedTo < lineText.length && lineText.charAt(expandedTo) === " ") {
            expandedTo++;
          } else if (expandedFrom > 0 && lineText.charAt(expandedFrom - 1) === " ") {
            expandedFrom--;
          }
          editor.replaceRange("", { line, ch: expandedFrom }, { line, ch: expandedTo });
        } else {
          editor.replaceRange(selected.slice(1), candidate.range.from, candidate.range.to);
        }
      }
    }
  }
  // ── Settings ────────────────────────────────────────────────────────────────
  async loadSettings() {
    var _a;
    const loaded = (_a = await this.loadData()) != null ? _a : {};
    const anyLoaded = loaded;
    const mode = anyLoaded.altClickTagMode;
    this.settings = {
      pinnedTags: Array.isArray(anyLoaded.pinnedTags) ? anyLoaded.pinnedTags.filter((t) => typeof t === "string") : DEFAULT_SETTINGS.pinnedTags,
      frequencyCutoff: typeof anyLoaded.frequencyCutoff === "number" && !isNaN(anyLoaded.frequencyCutoff) ? Math.max(0, Math.floor(anyLoaded.frequencyCutoff)) : DEFAULT_SETTINGS.frequencyCutoff,
      frequencyCutoffEnabled: typeof anyLoaded.frequencyCutoffEnabled === "boolean" ? anyLoaded.frequencyCutoffEnabled : DEFAULT_SETTINGS.frequencyCutoffEnabled,
      altClickTagMode: mode === "start-line" || mode === "in-place" || mode === "end-line" ? mode : DEFAULT_SETTINGS.altClickTagMode,
      mobileLongPressEnabled: typeof anyLoaded.mobileLongPressEnabled === "boolean" ? anyLoaded.mobileLongPressEnabled : DEFAULT_SETTINGS.mobileLongPressEnabled,
      mobileLongPressMs: typeof anyLoaded.mobileLongPressMs === "number" && !isNaN(anyLoaded.mobileLongPressMs) ? Math.max(250, Math.min(5e3, Math.floor(anyLoaded.mobileLongPressMs))) : DEFAULT_SETTINGS.mobileLongPressMs,
      showPlacementInStatusBar: typeof anyLoaded.showPlacementInStatusBar === "boolean" ? anyLoaded.showPlacementInStatusBar : DEFAULT_SETTINGS.showPlacementInStatusBar
    };
    await this.saveData(this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.app.workspace.trigger("flat-tag-view:settings-updated");
    this.updateStatusBar();
  }
  // ── View activation / style ────────────────────────────────────────────────
  async activateView() {
    const workspace = this.app.workspace;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (!rightLeaf)
        return;
      leaf = rightLeaf;
      await leaf.setViewState({ type: VIEW_TYPE });
    }
    workspace.revealLeaf(leaf);
  }
  addStyle() {
    const styleEl = document.createElement("style");
    styleEl.innerHTML = getStyles();
    document.head.appendChild(styleEl);
  }
};
